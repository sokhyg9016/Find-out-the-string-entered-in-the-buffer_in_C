# Find-out-the-string-entered-in-the-buffer_in_C<br>

| **작성일**       | **키워드**           |  **참고**|
| ------------- |:-------------:|:-------------:| 
| 2019.04.04     | `C` `FILE I/O` `Pointer` | - |

## Points
1.  FILE 포인터로 ```stdin```을 가리킨 상태에서 포인터를 이용하여 메모리 주소에 접근해 입력한 문자열을 디버그 모드에서 확인해보자.

1. 작업 환경: `Visual Stdio 2017` 이며, 2017버전은 현재(작성일, 2019.04.04) FILE 포인터의 구조체 맴버를 볼 수 없기에디버깅을 통해 **_ptr** 과 **_base** 등의 대략적인 위치를 알아냄.

1. 이 프로그램은 두 가지 포인터를 이용하여 입력한 문자열을 확인해 보고, 정상적인 출력을 위해 문자열 끝에 `NULL`을 넣고 난뒤에 출력해보는 프로그램이다.

1. 이 문제의 핵심은 포인터를 얼마만큼 잘 이해하고 활용할 수 있느냐이다. 처음 FILE 포인터 `fp`는 `stdin`을 가리키고 있으며, 이때 또다른 포인터를 사용하여 fp의 구조체 맴버인 `Placeholder`의 주소값을 가리키게 함.

1. 중요한 점은 이 상태에서 **base** 포인터가 어디에 위치하며, 또한 그 위치를 알았을때 포인터를 이용해 저장된 문자열이 저장되어 있는 주소로 어떻게 접근을 할 것이고, 또 어떻게 출력을 할 것인가 입니다.

1. 주소 또한 데이터형을 가지고 있으며, 형 변환이 가능하다는 점을 이용함. 특정 요소에 접근하고자 할 때 이러한 점을 잘 염두해 두고 접근할 것




## 2019.04.04: 왜 char*으로 접근할 수 없는 것인가?

중요한 점은 이 상태에서 'base'포인터가 어디에 위치하며, 또한 그 위치를 알았을때 포인터를 이용해 저장된 문자열이 저장되어 있는 주소로
어떻게 접근을 할 것이고, 또 어떻게 출력을 할 것인가 입니다.




## [수정: 2019.12.03] ```char*``` 으로 접근 가능하다!


소스 코드에서 왜 (char**)으로 형변환후에 출력했는가 하면, 디버그를 해보면 알 수 있듯이 원래부터 stdin에 존재하는 베이스포인터의 타입은 void** 입니다.

base포인터는 현재 입력된 값이 저장된 주소를 저장하고 있으며 문자열은 const char*, 즉 문자열의 주소를 저장하고 있는 포인터는 void**과 같은 이중 포인터가 되어야 합니다. 따라서 만약 char*을 통해 접근하고자 했다면, 우리는 base포인터로 밖에 접근하지 못하며, char* sch = (char*)base_p; -> *sch를 해도 base 포인터에 저장된 문자열이 저장된 곳의 주소값을 단순히 문자 형식으로만(char*을 역참조하여 출력하려면 char형이므로) 출력해줄 뿐입니다.


즉, 원래부터가 base 포인터의 타입은 2중 포인터이기 때문에 우리가 접근하여 문자열을 건드리고 싶다면 그 타입에 맞게 접근해야 원하고자 하는 답을 찾을 수 있다...

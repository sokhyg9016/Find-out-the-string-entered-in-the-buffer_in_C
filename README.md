# Find-out-the-string-entered-in-the-buffer_in_C<br>
<hr>
<br>
<font style = "font-size: 0.9rem; color: gray;">2019. 03. 06</font>
<br>
<br>
<font style = "font-family: 'Lato',sans-serif;">이 프로젝트는 FILE 포인터로 stdin을 가리킨 상태에서 포인터를 이용하여 메모리 주소에 접근해<br>
입력한 문자열을 디버그 모드에서 확인해 보는 프로젝트입니다.</font><br>
<br>
작업 환경은 Visual Stdio 2017 이며, 2017버전은 현재(작성일) FILE 포인터의 구조체 맴버를 볼 수 없기에<br>
여러 가지 테스트를 해본 결과 '_ptr'과 '_base'등이 <br>
어떠한 위치에 있는지를 알아냈습니다.<br>
<br>
이 프로젝트에서 만든 예제는 이 두 가지 포인터를 이용하여 입력한 문자열을 확인해 보고, 정상적인 출력을 위해 문자열 끝에 NULL('\0')을 넣고 난뒤에 <br>
출력해보는 내용을 담고 있습니다.<br>
<br>
이 문제의 핵심은 포인터를 얼마만큼 잘 이해하고 활용할 수 있느냐 였던 것 같습니다. 처음 FILE 포인터 fp는 stdin을 가리키고 있으며,<br>
이때 또다른 포인터를 사용하여 fp의 구조체 맴버인 'Placeholder'의 주소값을 가리키게 하였습니다.<br>
<br>
중요한 점은 이 상태에서 'base'포인터가 어디에 위치하며, 또한 그 위치를 알았을때 포인터를 이용해 저장된 문자열이 저장되어 있는 주소로<br>
어떻게 접근을 할 것이고, 또 어떻게 출력을 할 것인가 입니다.<br>
<br>
힌트아닌 힌트로서 주소 또한 데이터형을 가지고 있으며, 형 변환이 가능하다는 점입니다. 특정 요소에 접근하고자 할 때 이러한 점을 잘 염두해 두고<br>
접근하는 것이 핵심입니다.<br>


<br>
<b>2019.04.04: 왜 char*으로 접근할 수 없는 것인가?</b>
<br>
중요한 점은 이 상태에서 'base'포인터가 어디에 위치하며, 또한 그 위치를 알았을때 포인터를 이용해 저장된 문자열이 저장되어 있는 주소로<br>
어떻게 접근을 할 것이고, 또 어떻게 출력을 할 것인가 입니다.<br>
<br>
<br>
소스 코드에서 왜 (char**)으로 형변환후에 출력했는가 하면, 디버그를 해보면 알 수 있듯이 원래부터 stdin에 존재하는 베이스포인터의 타입은 char**, 혹은 const char** 일 것입니다.<br>
그 이유는 일단 메모리를 보면 base포인터는 문자열이 저장된 주소를 저장하고 있으며 문자열은 const char*, 즉 문자열의 주소를 저장하고 있는 포인터는 char**이 되어야 합니다. 따라서 만약 char*을 통해 접근하고자 했다면, 우리는 base포인터로 밖에 접근하지 못했을 것이다.<br><br>
즉, 원래부터가 base 포인터의 타입은 2중 포인터이기 때문에 우리가 접근하여 문자열을 건드리고 싶다면 그 타입에 맞게 접근해야 원하고자 하는 답을 찾을 수 있다...<br>
<br>
<br>
